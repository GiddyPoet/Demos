## 实现三种队列  

分别是

- [顺序队列](./1.go)
    - [顺序队列，线程安全版-加锁1.1](./1.1.go)
    - [顺序队列，线程安全版-chan1.2](./1.2.go)

- [循环队列](./2.go)
    - [循环队列，线程安全版-加锁1.1](./2.1.go)
    - [循环队列，线程安全版-chan1.2](./2.2.go)

- [链表队列](./3.go)
    - [链表队列，线程安全版-加锁1.1](./3.1.go)
    - [链表队列，线程安全版-chan1.2](./3.2.go)


顺序队列 ： 只能队列的尾部加上数据，然后队伍的头部取出数据,实现方法也很容易，队尾部 append一个数据，然后队伍的队首取出一个数据使用slice[1:]
即可。

循环队列：最重要的一个点就是 每次复制后 front和trail都要往下一个移动 也就是 出队列的时候` (front +1)%cap` 和 入队列的时候 `(trail+1)%cap`

我们也要看什么时候不行的时候 也就是满了，就是 当 `(trail+1)%cap == front%cap` 就不能再往里面加东西了。

循环队列最重要的就是这个求模 也就是说 因为是一个循环，所以求模是最重要的行为 

举个例子:

```go
//一个cap=3的slice

//当 tril退到3的时候，那么前面 假如两个空余，那么应该0放一个 1放一个 怎么放？ 使用 2 下一个该3 了，但是没有3 这个下标，所以应该是 2 +1 % 3 就是0

// 在下一位呢，0+1 %3 == 1 就是这个意思。

```

链表队列：

首先有一个struct 当做一个盒子 这个盒子里有一个链子  这个链子 就是那个队列
```go

//首先

type box struct{
	
length int
head *node 这个盒子记录了 你的链子的首链和尾链
tail *node
}

type node struct { //⛓ 链条的一个单元
	
value 它的值 
next *node  // 这是它下一个兄弟的 指针，它记录一下 这样就可以找到下一个兄弟了， 这也就是一个 单链表
}

```
实现的时候只要每次 将这次的最后的那个节点的next 等于一个新的节点，然后 再尾节点等于这个新的节点就ok了。这样既将当期的节点搞定也创造了一个新的节点

出队列的时候也是一样，将获取当前的head 然后寻找到它的next，然后将新的box的head指向next就ok了。